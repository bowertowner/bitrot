<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Bitrot â€“ Community Digital Crate</title>
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        margin: 0;
        padding: 0;
        background: #0b0b0e;
        color: #f5f5f5;
      }

      header {
        padding: 16px 24px;
        border-bottom: 1px solid #25252b;
        display: flex;
        align-items: baseline;
        justify-content: space-between;
      }

      .header-left h1 {
        margin: 0;
        font-size: 20px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
      }

      .header-left span {
        font-size: 12px;
        color: #9ca3af;
      }

      .header-right {
        font-size: 12px;
        color: #9ca3af;
      }

      .header-stats {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }

	  .stats-bar {
	  	font-size: 11px;
	  	color: var(--muted);
	  	display: flex;
	  	gap: 8px;
	  	align-items: center;
	  	justify-content: flex-end;
	  }
	  
	  .stats-bar span.dot {
	    width: 3px;
	    height: 3px;
	    border-radius: 999px;
	    background: rgba(148, 163, 184, 0.7);
	  }

	  main {
		padding: 16px 24px 40px;
	  
		/* WIDTH KNOB: change this if you want a max width cap */
		max-width: none;
	  
		/* keeps it from sticking left; remove margin if you want full-bleed */
		margin: 0 auto;
	  }

      section {
        margin-bottom: 24px;
      }

      h2 {
        margin: 0 0 8px;
        font-size: 16px;
      }

      .section-subtitle {
        font-size: 12px;
        color: #9ca3af;
        margin-bottom: 12px;
      }

      .panel {
        border: 1px solid #25252b;
        border-radius: 8px;
        padding: 12px 14px;
        background: #111118;
      }

      .panel + .panel {
        margin-top: 12px;
      }

      .spotify-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 999px;
        border: 1px solid transparent;
        padding: 6px 14px;
        font-size: 13px;
        cursor: pointer;
        text-decoration: none;
        white-space: nowrap;
      }

      .btn-primary {
        background: #1db954;
        color: #041308;
        border-color: #16a34a;
        font-weight: 600;
      }

      .btn-secondary {
        background: #111827;
        color: #e5e7eb;
        border-color: #374151;
      }

      .btn:disabled {
        opacity: 0.6;
        cursor: default;
      }

      .badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 11px;
        border: 1px solid #374151;
        background: #020617;
        color: #9ca3af;
      }

      .input-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }

      label {
        font-size: 12px;
        color: #9ca3af;
      }

      input,
      select {
        font-family: inherit;
        font-size: 13px;
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid #374151;
        background: #020617;
        color: #e5e7eb;
      }

      input::placeholder {
        color: #6b7280;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 12px;
        font-size: 13px;
      }

	  th,
	  td {
		padding: 6px 8px;
		border-bottom: 1px solid #1f2933;
		vertical-align: middle;
	  }
	  
	  /* 100px row requirement */
	  tbody#releases-body tr {
		height: 100px;
	  }
	  
	  /* Make the art cell flush so 100x100 art fits perfectly */
	  td.art-cell {
		padding: 0 !important;
		width: 100px;
	  }
	  td.art-cell .release-thumb {
		display: block;
		width: 100px !important;
		height: 100px !important;
		border-radius: 6px;
	  }

      th {
        text-align: left;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: #9ca3af;
      }

      th.sortable {
        cursor: pointer;
      }

      th.sortable:hover {
        color: #e5e7eb;
      }

      tbody tr:hover {
        background: #111827;
      }

      a.release-link {
        color: #93c5fd;
        text-decoration: none;
      }

      a.release-link:hover {
        text-decoration: underline;
      }

      .tag-chip {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 999px;
        background: #020617;
        border: 1px solid #374151;
        font-size: 11px;
        margin: 0 4px 2px 0;
        color: #e5e7eb;
        cursor: pointer;
      }

      #spotify-overlap-output {
        font-size: 12px;
        color: #d1d5db;
        margin-top: 6px;
        white-space: pre-line;
      }

      #status {
        font-size: 11px;
        color: #9ca3af;
        margin-top: 6px;
      }

	  #release-details {
		display: none !important;
	  }


      .pagination-row {
        display: flex;
        justify-content: flex-end;
        gap: 6px;
        margin-top: 8px;
        font-size: 12px;
        color: #9ca3af;
      }

      .pagination-row button {
        padding: 3px 8px;
        border-radius: 999px;
        border: 1px solid #374151;
        background: #020617;
        color: #e5e7eb;
        cursor: pointer;
      }

      .pagination-row button:disabled {
        opacity: 0.4;
        cursor: default;
      }

      .details-heading {
        font-size: 14px;
        margin: 0 0 4px;
      }

      .details-sub {
        font-size: 12px;
        color: #9ca3af;
        margin: 0 0 8px;
      }

      .details-label {
        font-size: 12px;
        color: #9ca3af;
      }

      .details-value {
        font-size: 13px;
      }

	  .track-table {
		margin-top: 8px;
		border-top: 1px solid #1f2933;
	  }
			
	  /* --- Expanded view layout: media left, meta middle, tracks right --- */
	  .details-top {
		display: grid;
		grid-template-columns: 350px minmax(280px, 1fr) minmax(320px, 1fr);
		gap: 16px;
		align-items: start;
	  
		/* Lock the whole expanded â€œtopâ€ section to the player height */
		height: 470px;
	  }
	  
	  .details-media {
		width: 350px;
		height: 470px;
	  }
	  
	  .details-meta {
		min-width: 280px;
		height: 470px;            /* lock to player height */
		overflow: auto;           /* if meta runs long, scroll inside */
		padding-right: 6px;       /* room for scrollbar */
	  }
	  
	  .details-right {
		min-width: 320px;
		height: 470px;            /* lock to player height */
		display: flex;
		flex-direction: column;
	  }
	  
	  .details-tracks-right {
		flex: 1 1 auto;
		overflow: auto;
		padding-right: 6px;       /* room for scrollbar */
	  }
	  
	  /* Tracklist visuals: transparent rows, compact height, subtle separators */
	  .tracklist {
		margin-top: 6px;
		border-top: 1px solid rgba(255, 255, 255, 0.10);
	  }
	  
	  .track-row {
		display: flex;
		gap: 10px;
		align-items: baseline;
		justify-content: space-between;
	  
		padding: 4px 2px; /* compact */
		border-bottom: 1px solid rgba(255, 255, 255, 0.08);
		background: transparent;
	  }
	  
	  .track-title {
		flex: 1 1 auto;
		min-width: 0;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	  }
	  
	  .track-dur {
		flex: 0 0 auto;
		color: rgba(229, 231, 235, 0.75);
		font-variant-numeric: tabular-nums;
	  }
	  
	  /* --- Bandcamp player sizing (prevents "banner strip" clipping) --- */
	  .bc-media-shell {
		width: 350px;
		height: 470px;
		border-radius: 8px;
		overflow: hidden;
		border: 1px solid #1f2933;
		background: #111118;
	  }
	  
	  .bc-media-shell.is-expanded {
		width: 350px;
		height: 470px;
	  }
	  
	  .bc-iframe {
		border: 0;
		width: 100%;
		height: 100%;
		display: block;
		background: #111118;
	  }
	  
	  .bc-fallback-art {
		width: 100%;
		height: 100%;
		object-fit: cover;
		display: block;
	  }
	  
	  .bc-no-art {
		width: 100%;
		height: 100%;
		display: flex;
		align-items: center;
		justify-content: center;
		color: #6b7280;
		font-size: 12px;
	  }

      .track-table th,
      .track-table td {
        border-bottom: 1px solid #1f2933;
      }

	  /* Inline expanded details inside the releases table */
	  .inline-details-row td {
		/* default, will be overridden by theme vars when available */
		background: #030712;
		border-top: 1px solid #1f2933;
		padding: 12px 16px;
	  }
	  
	  /* --- Themed expanded pane (Spotify-ish, but cooler) --- */
	  .inline-details.theme-on {
		position: relative;
		border-radius: 10px;
		overflow: hidden;
	  
		/* theme variables set by JS */
		background: var(--pane-bg, #030712);
		color: var(--pane-fg, #e5e7eb);
		border: 1px solid rgba(31, 41, 51, 0.9);
	  }
	  
	  .inline-details.theme-on .details-label,
	  .inline-details.theme-on .inline-details-label {
		color: var(--pane-muted, rgba(229, 231, 235, 0.72));
	  }
	  
	  .inline-details.theme-on a.release-link {
		color: var(--pane-link, #93c5fd);
	  }
	  
	  .inline-details.theme-on code {
		color: var(--pane-fg, #e5e7eb) !important;
	  }
	  
	  /* blurred artwork backdrop fallback (always works) */
	  .inline-details.theme-on::before {
		content: "";
		position: absolute;
		inset: -30px;
		background-image: var(--pane-bgimg, none);
		background-size: cover;
		background-position: center;
		filter: blur(26px) saturate(1.35) contrast(1.05);
		transform: scale(1.08);
		opacity: 0.55;
		pointer-events: none;
	  }
	  
	  /* dark overlay for legibility */
	  .inline-details.theme-on::after {
		content: "";
		position: absolute;
		inset: 0;
		background: linear-gradient(
			135deg,
			rgba(0, 0, 0, 0.68) 0%,
			rgba(0, 0, 0, 0.42) 45%,
			rgba(0, 0, 0, 0.72) 100%
		  );
		pointer-events: none;
	  }
	  
	  /* ensure content sits above overlays */
	  .inline-details.theme-on > * {
		position: relative;
		z-index: 1;
	  }

	  .releases-scroll {
		/* HEIGHT KNOB: tweak this value */
		height: calc(100vh - 220px);
	  
		overflow-y: auto;
		border: 1px solid #25252b;
		border-radius: 6px;
	  }

      .inline-details {
        font-size: 12px;
        color: #e5e7eb;
        line-height: 1.4;
      }
      
      .inline-details-header {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-bottom: 8px;
      }
      
      .inline-details-label {
        font-weight: 600;
        color: #9ca3af;
        margin-right: 4px;
      }
      
      .inline-details-tags {
        margin-top: 6px;
      }

      .inline-details-tracks {
        margin-top: 8px;
      } 
      
      .inline-details-tracks table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 4px;
        font-size: 11px;
      }

      .inline-details-tracks th,
      .inline-details-tracks td {
        border-top: 1px solid #1f2933;
        padding: 2px 4px;
        text-align: left;
      }

      .artists-table-container,
      .tags-table-container {
        max-height: 260px;
        overflow-y: auto;
        margin-top: 8px;
      }

      .copy-id-btn {
        font-size: 8px;
        padding: 2px 6px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.7);
        background: transparent;
        color: #9ca3af;
        cursor: pointer;
      }

      .copy-id-btn:hover {
        background: rgba(148, 163, 184, 0.08);
      }

      .artist-filter-btn {
        border: none;
        background: none;
        padding: 0;
        margin: 0;
        font: inherit;
        color: #60a5fa; /* soft blue link */
        cursor: pointer;
      }

      .artist-filter-btn:hover {
        text-decoration: underline;
      }

	  /* Discogs confidence link */
	  a.discogs-link {
  		font-weight: 700;
  		text-decoration: none;
	  }
	  a.discogs-link:hover {
  		text-decoration: underline;
	  }

	  a.discogs-low {
  		color: #fb923c; /* orange */
	  }
	  a.discogs-med {
  		color: #facc15; /* yellow */
	  }
	  a.discogs-high {
  		color: #22c55e; /* green */
	  }
	  span.discogs-none {
  		color: #6b7280; /* muted gray */
	  }

	  /* Discogs "not found" pill */
	  span.discogs-not-found {
		display: inline-block;
		font-size: 14px;
		line-height: 1;
		cursor: default;
		color: #ffffff
	  }

	  /* Optional "checking" style */
	  span.discogs-checking {
  		color: #9ca3af;
	  }

      #active-tags {
        margin-top: 6px;
        font-size: 12px;
        color: #9ca3af;
      }
      
	  .header-right {
		display: flex;
		flex-direction: column;
		align-items: flex-end;
	  }
	  
	  .stats-link {
		margin-top: 6px;
		font-size: 12px;
		color: #60a5fa;
		text-decoration: none;
	  }
	  
	  .stats-link:hover {
		text-decoration: underline;
	  }
      
      /* --- MVP auth bar --- */
      .auth-bar {
        margin-top: 10px;
        display: flex;
        justify-content: flex-end;
        width: 100%;
      }

      .auth-logged-out,
      .auth-logged-in {
        display: flex;
        gap: 6px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: flex-end;
        max-width: 720px;
      }

      .auth-logged-out input {
        width: 150px;
        font-size: 12px;
        padding: 4px 8px;
      }

      .auth-msg {
        font-size: 11px;
        color: #9ca3af;
        margin-left: 6px;
      }

      .auth-user-link {
        color: #93c5fd;
        text-decoration: none;
        font-weight: 700;
      }

      .auth-user-link:hover {
        text-decoration: underline;
      }

      /* --- Stickers / voting UI in expanded pane --- */
      .stickers-panel {
        margin-top: 12px;
        border-top: 1px solid rgba(255, 255, 255, 0.10);
        padding-top: 10px;
      }

      .stickers-add-row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
        margin-top: 6px;
      }

      .stickers-add-row input {
        width: 240px;
        font-size: 12px;
      }

      .typeahead {
        position: relative;
      }

      .typeahead-list {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: #020617;
        border: 1px solid #374151;
        border-radius: 6px;
        z-index: 9999;
        max-height: 220px;
        overflow: auto;
        margin-top: 4px;
        display: none;
      }

      .typeahead-item {
        padding: 6px 8px;
        font-size: 12px;
        cursor: pointer;
        border-bottom: 1px solid rgba(55, 65, 81, 0.35);
      }

      .typeahead-item:hover {
        background: rgba(148, 163, 184, 0.10);
      }

      .attach-row {
        margin-top: 8px;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .attach-chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 3px 8px;
        border-radius: 999px;
        border: 1px solid rgba(55, 65, 81, 0.9);
        background: rgba(2, 6, 23, 0.65);
        font-size: 11px;
      }

      .attach-source {
        color: rgba(229, 231, 235, 0.65);
        font-size: 10px;
      }

      .src-icon {
        width: 11px;
        height: 11px;
        display: inline-block;
        vertical-align: -2px;
        margin-right: 4px;
      }

      .vote-btn {
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: transparent;
        color: rgba(229, 231, 235, 0.85);
        border-radius: 999px;
        padding: 1px 6px;
        font-size: 11px;
        cursor: pointer;
        line-height: 1;
      }

      /* Active state (user has voted) */
      .vote-btn.active {
        border-color: rgba(255, 255, 255, 0.35);
        background: rgba(255, 255, 255, 0.10);
        color: rgba(255, 255, 255, 0.95);
      }

      .vote-btn.vote-up.active {
        border-color: rgba(34, 197, 94, 0.55);
        background: rgba(34, 197, 94, 0.16);
        color: rgba(34, 197, 94, 0.95);
      }

      .vote-btn.vote-down.active {
        border-color: rgba(239, 68, 68, 0.55);
        background: rgba(239, 68, 68, 0.16);
        color: rgba(239, 68, 68, 0.95);
      }

      .vote-btn:disabled {
        opacity: 0.4;
        cursor: default;
      }

      .vote-count {
        font-variant-numeric: tabular-nums;
        color: rgba(229, 231, 235, 0.85);
      }

      .remove-btn {
        border: 1px solid rgba(251, 113, 133, 0.35);
        background: transparent;
        color: rgba(251, 113, 133, 0.95);
        border-radius: 999px;
        padding: 1px 6px;
        font-size: 11px;
        cursor: pointer;
      }

      .remove-btn:disabled {
        opacity: 0.35;
        cursor: default;
      }
      
    </style>
    
    
  </head>
  <body>
    <header>
  	  <div class="header-left">
    	<h1>Bitrot</h1>
    	<span>Community-sourced digital release index</span>
  	  </div>
  	   
	  <div class="header-right">
		<div class="stats-bar">
		  <span id="stats-total-releases">0 releases</span>
		  <span class="dot"></span>
		  <span id="stats-total-artists">0 artists</span>
		  <span class="dot"></span>
		  <span id="stats-total-tracks">0 tracks</span>
		  <span class="dot"></span>
		  <span id="stats-total-free-releases">0 free/NYP releases</span>
		  <span class="dot"></span>
		  <span id="stats-total-free-tracks">0 free/NYP tracks</span>
		</div>

        <!-- MVP account UI -->
        <div class="auth-bar" id="auth-bar">
          <div class="auth-logged-out" id="auth-logged-out">
            <input id="auth-username" type="text" placeholder="username" />
            <input id="auth-email" type="text" placeholder="email (signup only)" />
            <input id="auth-password" type="password" placeholder="password" />
            <button class="btn btn-secondary" id="auth-login-btn">Log in</button>
            <button class="btn btn-secondary" id="auth-signup-btn">Sign up</button>
            <span class="auth-msg" id="auth-msg"></span>
          </div>

          <div class="auth-logged-in" id="auth-logged-in" style="display:none;">
            <span class="auth-who">logged in as <a id="auth-user-link" class="auth-user-link" href="#"></a></span>
            <button class="btn btn-secondary" id="auth-logout-btn">Log out</button>
            <span class="auth-msg" id="auth-msg-in"></span>
          </div>
        </div>
	  
		<a class="stats-link" href="/stats/">view more stats â†’</a>
	  </div>

	</header>

    <main>
      <!-- Spotify Section -->
      <section style="display: none;">
        <h2>Spotify Library Overlap</h2>
        <p class="section-subtitle">
          Connect your Spotify account and see how many of your saved releases already exist in Bitrot.
        </p>
        <div class="panel">
          <div class="spotify-row">
            <a class="btn btn-primary" href="/login" id="spotify-connect">
              Connect Spotify
            </a>
            <button class="btn btn-secondary" id="spotify-check-overlap">
              Check overlap
            </button>
            <label
              style="
                font-size: 12px;
                color: #9ca3af;
                display: inline-flex;
                align-items: center;
                gap: 4px;
              "
            >
              <input type="checkbox" id="spotify-overlap-free-only" />
              Free / NYP only
            </label>
            <span class="badge">MVP Â· saved tracks only</span>
          </div>
          <div id="spotify-overlap-output"></div>
        </div>

        <div class="panel">
          <h3 style="margin: 0 0 8px; font-size: 13px">
            Overlapping releases in Bitrot
          </h3>
          <table>
            <thead>
              <tr>
                <th>Artist</th>
                <th>Title</th>
                <th>Price</th>
                <th>Free</th>
                <th>Release date</th>
                <th>Tags</th>
                <th>Source</th>
              </tr>
            </thead>
            <tbody id="spotify-overlap-body">
              <tr>
                <td colspan="7" style="font-size: 12px; color: #9ca3af">
                  Run "Check overlap" to see matching releases from your Spotify
                  library.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <!-- Filters + Releases Section -->
      <section>
        <h2>Releases</h2>
        <p class="section-subtitle">
          Releases seen by real humans via the Bandcamp extensions. Use filters
          to dig for free / NYP material.
        </p>
        <div class="panel">
         <div class="input-row">
  			<label>
   			  Artist
    		  <input
      			id="filter-artist"
      			type="text"
      			placeholder="e.g. Dead Trooper"
    		  />
  			</label>

  			<label>
    		  Release ID
    		  <input
     			id="filter-id"
     			type="text"
      			placeholder="UUID prefix / fragment"
    		  />
  			</label>

  			<label>
    		  Free / NYP
    		  <select id="filter-free">
     			<option value="">Any</option>
      			<option value="true">Free only</option>
      			<option value="false">Paid only</option>
   			  </select>
 			</label>

 			<label>
    		  Tag
    		  <input
      			id="filter-tag"
      			type="text"
      			placeholder="Type tag + Enter to add"
    		  />
  			</label>

  			<label>
    		  Global search
    		  <input
      			id="filter-global"
      			type="text"
      			placeholder="artist / title / tag / URL"
    		  />
  			</label>

  			<button class="btn btn-secondary" id="filter-apply">
    		  Apply filters
  			  </button>
		  </div>

          <div id="active-tags"></div>
          <div id="status"></div>
        </div>

        <div class="panel">
        <div class="releases-scroll">
         <div class="panel">
          <table>
            <thead>
			  <tr>
				<th style="display:none;">ID</th>
				<th>Art</th>
				<th class="sortable" data-sort="artist">Artist</th>
				<th class="sortable" data-sort="title">Title</th>
				<th class="sortable" data-sort="price">Price</th>
				<th class="sortable" data-sort="release_date">Release date</th>
				<th>Tags</th>
				<th class="sortable" data-sort="encounters">Encounters</th>
				<th>Source</th>
				<th>Discogs</th>
			  </tr>

            </thead>
            <tbody id="releases-body">
              <!-- Filled by JS -->
            </tbody>
          </table>
         </div>
        </div>
      
    </main>

    <script>
    
    
// ---------- Helpers ----------

	// --- Album artwork theming for expanded pane ---
	// Hybrid approach:
	// 1) Always set a blurred background using the art URL (works even if CORS blocks canvas).
	// 2) Try to sample pixels via canvas for a dominant color + readable text color. If blocked, keep fallback.
	async function applyArtworkThemeToExpandedPane(containerEl, artUrl) {
	  try {
		if (!containerEl) return;
	
		// Turn on theming class
		containerEl.classList.add("theme-on");
	
		// Always set the blurred background fallback
		if (artUrl) {
		  containerEl.style.setProperty("--pane-bgimg", `url("${String(artUrl).replace(/"/g, '\\"')}")`);
		} else {
		  containerEl.style.removeProperty("--pane-bgimg");
		}
	
		if (!artUrl) return;
	
		// Attempt canvas sampling (may fail if image host blocks CORS)
		const img = new Image();
		img.crossOrigin = "anonymous";
		img.decoding = "async";
		img.loading = "eager";
		img.src = artUrl;
	
		await new Promise((resolve, reject) => {
		  img.onload = () => resolve(true);
		  img.onerror = () => reject(new Error("artwork image failed to load"));
		});
	
		const canvas = document.createElement("canvas");
		const ctx = canvas.getContext("2d", { willReadFrequently: true });
		if (!ctx) return;
	
		// Downsample heavily for speed
		const w = 48;
		const h = 48;
		canvas.width = w;
		canvas.height = h;
		ctx.drawImage(img, 0, 0, w, h);
	
		const { data } = ctx.getImageData(0, 0, w, h);
	
		// Compute average color, ignoring near-transparent pixels
		let r = 0, g = 0, b = 0, n = 0;
		for (let i = 0; i < data.length; i += 4) {
		  const a = data[i + 3];
		  if (a < 16) continue;
		  r += data[i];
		  g += data[i + 1];
		  b += data[i + 2];
		  n++;
		}
		if (!n) return;
	
		r = Math.round(r / n);
		g = Math.round(g / n);
		b = Math.round(b / n);
	
		// Slightly darken to keep the UI legible
		const darken = 0.72;
		const bgR = Math.round(r * darken);
		const bgG = Math.round(g * darken);
		const bgB = Math.round(b * darken);
	
		// Pick readable text color based on luminance
		const luminance = (0.2126 * bgR + 0.7152 * bgG + 0.0722 * bgB) / 255;
		const fg = luminance > 0.55 ? "#0b0b0e" : "#f5f5f5";
	
		// Muted label color derived from fg
		const muted = luminance > 0.55 ? "rgba(11,11,14,0.72)" : "rgba(245,245,245,0.72)";
		const link = luminance > 0.55 ? "#1d4ed8" : "#93c5fd";
	
		containerEl.style.setProperty("--pane-bg", `rgb(${bgR}, ${bgG}, ${bgB})`);
		containerEl.style.setProperty("--pane-fg", fg);
		containerEl.style.setProperty("--pane-muted", muted);
		containerEl.style.setProperty("--pane-link", link);
	  } catch (_e) {
		// If canvas sampling fails (tainted canvas, etc.), the blurred bg fallback still works.
		// Do nothing.
	  }
	}
	
		const DISCOGS_COOLDOWN_MS = 60 * 60 * 1000; // 1 hour
		const DEV_DISCOGS_REFRESH = true; // dev-only refresh button in expanded pane

	
	function discogsCooldownKey(releaseId) {
	  return `discogs:last_match_attempt:${releaseId}`;
	}
	
	function setDiscogsCooldownNow(releaseId) {
	  try {
		localStorage.setItem(discogsCooldownKey(releaseId), String(Date.now()));
	  } catch (_e) {}
	}
	
	function getDiscogsCooldownAgeMs(releaseId) {
	  try {
		const raw = localStorage.getItem(discogsCooldownKey(releaseId));
		if (!raw) return Infinity;
		const t = Number(raw);
		if (!Number.isFinite(t)) return Infinity;
		return Date.now() - t;
	  } catch (_e) {
		return Infinity;
	  }
	}
	
	function renderDiscogsCell(td, info) {
	  // Not triggered yet
	  if (!info) {
		td.innerHTML = `<span class="discogs-none">-</span>`;
		return;
	  }
	
	  // Not found / rejected should stick
	  if (info.status === "not_found" || info.status === "rejected") {
		td.innerHTML = `<span class="discogs-not-found" style="color:#ffffff;" title="Not Found On Discogs">ðŸ™ˆ</span>`;
		return;
	  }
	
	  // If we don't have a Discogs release id, we can't link
	  if (info.discogs_release_id == null) {
		td.innerHTML = `<span class="discogs-none">-</span>`;
		return;
	  }
	
	  const score =
		info.confidence_score == null
		  ? null
		  : Math.max(0, Math.min(100, Number(info.confidence_score)));
	
	  const avg =
		info.discogs_rating_average == null ? null : Number(info.discogs_rating_average);
	
	  const count =
		info.discogs_rating_count == null ? null : Number(info.discogs_rating_count);
	
	  const discogsUrl =
		"https://www.discogs.com/release/" + encodeURIComponent(info.discogs_release_id);
	
	  const baseTooltip =
		score == null
		  ? "Discogs match found."
		  : `We are ${Math.round(score)}% sure that this is the correct release.`;
	
	  // If Discogs has no ratings yet, show "--/5" in white (no gradient),
	  // and add extra tooltip guidance.
	  const noRatings = count === 0;
	
	  let ratingText = "â€”";
	  let linkStyle = "color:#9ca3af;";
	  let tooltip = baseTooltip;
	
	  if (noRatings) {
		ratingText = "--/5";
		linkStyle = "color:#ffffff;";
		tooltip =
		  baseTooltip +
		  " This release has no ratings yet. Click this link to leave a rating on Discogs.";
	  } else if (avg != null && Number.isFinite(avg)) {
		ratingText = `${avg.toFixed(1)}/5`;
	
		// Color gradient based on Discogs rating (0â€“5): red -> yellow -> green
		const clamped = Math.max(0, Math.min(5, avg));
		const hue = (clamped / 5) * 120; // 0=red, 120=green
		linkStyle = `color: hsl(${hue}, 80%, 55%);`;
	  }
	
	  td.innerHTML = `
		<a class="discogs-link"
		   style="${linkStyle}"
		   href="${discogsUrl}"
		   target="_blank"
		   rel="noreferrer"
		   title="${tooltip.replace(/"/g, "&quot;")}">
		  ${ratingText}
		</a>
	  `;
	}
	
	async function hydrateDiscogsCellsForVisibleRows(_rowsIgnored) {
	  try {
		const cells = Array.from(
		  document.querySelectorAll('td[data-discogs-cell="1"][data-release-id]')
		);
		if (cells.length === 0) return;
	
		const ids = cells
		  .map((td) => td.getAttribute("data-release-id"))
		  .map((s) => (s ? s.trim() : ""))
		  .filter(Boolean);
	
		if (ids.length === 0) return;
	
		const res = await fetch("/discogs/status?ids=" + encodeURIComponent(ids.join(",")));
		if (!res.ok) {
		  console.warn("[Discogs UI] status endpoint failed:", res.status);
		  return;
		}
	
		const statusMap = await res.json();
	
		for (const td of cells) {
		  const id = (td.getAttribute("data-release-id") || "").trim();
		  if (!id) continue;
		  renderDiscogsCell(td, statusMap[id]);
		}
	  } catch (e) {
		console.error("hydrateDiscogsCellsForVisibleRows failed", e);
	  }
	}
	
	async function hydrateDiscogsCellForReleaseId(releaseId) {
	  try {
		const td = document.querySelector(
		  `td[data-discogs-cell="1"][data-release-id="${CSS.escape(releaseId)}"]`
		);
		if (!td) return;
	
		const res = await fetch("/discogs/status?ids=" + encodeURIComponent(releaseId));
		if (!res.ok) return;
	
		const statusMap = await res.json();
		renderDiscogsCell(td, statusMap[releaseId]);
	  } catch (e) {
		console.error("hydrateDiscogsCellForReleaseId failed", e);
	  }
	}
	
	async function triggerDiscogsMatchForReleaseId(releaseId, opts = {}) {
	  try {
		const force = opts && opts.force === true;
	
	    const td = document.querySelector(
		  `td[data-discogs-cell="1"][data-release-id="${CSS.escape(releaseId)}"]`
		);
		if (!td) return;
	
		// Frontend cooldown (1 hour) unless force
		if (!force) {
		  const age = getDiscogsCooldownAgeMs(releaseId);
		  if (age < DISCOGS_COOLDOWN_MS) {
			await hydrateDiscogsCellForReleaseId(releaseId);
			return;
		  }
		}
	
		setDiscogsCooldownNow(releaseId);
		td.innerHTML = `<span class="discogs-checking">Checking Discogsâ€¦</span>`;
	
		const url =
		  "/discogs/match/" +
		  encodeURIComponent(releaseId) +
		  (force ? "?force=1" : "");
	
		const res = await fetch(url, {
		  method: "POST",
		  headers: { "Content-Type": "application/json" },
		});
	
		if (!res.ok) {
		  td.innerHTML = `<span class="discogs-none">-</span>`;
		  return;
		}
	
		// Only set cooldown AFTER the POST succeeded (otherwise failures can "stick")
		setDiscogsCooldownNow(releaseId);
		await hydrateDiscogsCellForReleaseId(releaseId);
	  } catch (e) {
		console.error("triggerDiscogsMatchForReleaseId failed", e);
	  }
	}

      const releaseDetailsEl = document.getElementById("release-details");
      const tagInput = document.getElementById("filter-tag");
      const activeTagsEl = document.getElementById("active-tags");

      // ---------- Auth state (MVP) ----------
      let __bitrotMe = null;

      const authLoggedOutEl = document.getElementById("auth-logged-out");
      const authLoggedInEl = document.getElementById("auth-logged-in");
      const authMsgEl = document.getElementById("auth-msg");
      const authMsgInEl = document.getElementById("auth-msg-in");

      const authUsernameEl = document.getElementById("auth-username");
      const authEmailEl = document.getElementById("auth-email");
      const authPasswordEl = document.getElementById("auth-password");

      const authLoginBtn = document.getElementById("auth-login-btn");
      const authSignupBtn = document.getElementById("auth-signup-btn");
      const authLogoutBtn = document.getElementById("auth-logout-btn");
      const authUserLinkEl = document.getElementById("auth-user-link");

      function setAuthMsg(msg, loggedIn = false) {
        const el = loggedIn ? authMsgInEl : authMsgEl;
        if (!el) return;
        el.textContent = msg || "";
      }

      async function fetchMe() {
        try {
          const res = await fetch("/auth/me", { credentials: "same-origin" });
          if (!res.ok) return null;
          return await res.json();
        } catch {
          return null;
        }
      }

      function renderAuthUI() {
        const me = __bitrotMe;

        if (!authLoggedOutEl || !authLoggedInEl) return;

        if (!me) {
          authLoggedOutEl.style.display = "flex";
          authLoggedInEl.style.display = "none";
          if (authUserLinkEl) authUserLinkEl.textContent = "";
          return;
        }

        authLoggedOutEl.style.display = "none";
        authLoggedInEl.style.display = "flex";
        if (authUserLinkEl) {
          authUserLinkEl.textContent = me.username || "";
          authUserLinkEl.href = "/user/" + encodeURIComponent(me.username || "");
        }
      }

      async function refreshAuthState() {
        __bitrotMe = await fetchMe();
        renderAuthUI();
      }

      async function authPost(path, body) {
        const res = await fetch(path, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "same-origin",
          body: JSON.stringify(body || {}),
        });

        let data = null;
        try {
          data = await res.json();
        } catch {
          data = null;
        }

        return { ok: res.ok, status: res.status, data };
      }

      if (authLoginBtn) {
        authLoginBtn.addEventListener("click", async () => {
          setAuthMsg("", false);
          const username = String(authUsernameEl?.value || "").trim();
          const password = String(authPasswordEl?.value || "");

          if (!username || !password) {
            setAuthMsg("Username + password required.", false);
            return;
          }

          const { ok, data } = await authPost("/auth/login", { username, password });
          if (!ok) {
            setAuthMsg((data && data.error) || "Login failed.", false);
            return;
          }

          setAuthMsg("Logged in.", false);
          await refreshAuthState();
        });
      }

      if (authSignupBtn) {
        authSignupBtn.addEventListener("click", async () => {
          setAuthMsg("", false);
          const username = String(authUsernameEl?.value || "").trim();
          const email = String(authEmailEl?.value || "").trim();
          const password = String(authPasswordEl?.value || "");

          if (!username || !email || !password) {
            setAuthMsg("Username + email + password required for signup.", false);
            return;
          }

          const { ok, data } = await authPost("/auth/signup", { username, email, password });
          if (!ok) {
            setAuthMsg((data && data.error) || "Signup failed.", false);
            return;
          }

          setAuthMsg("Account created. Logged in.", false);
          await refreshAuthState();
        });
      }

      if (authLogoutBtn) {
        authLogoutBtn.addEventListener("click", async () => {
          setAuthMsg("", true);
          await authPost("/auth/logout", {});
          __bitrotMe = null;
          renderAuthUI();
          setAuthMsg("Logged out.", true);
        });
      }

      // Selected tags (multi, AND semantics enforced on backend)
      let selectedTags = [];

      function scrollToReleases() {
        const releasesSection = document.querySelectorAll("section")[1];
        if (!releasesSection) return;
        const top = releasesSection.offsetTop - 20;
        window.scrollTo({ top, behavior: "smooth" });
      }

      function formatDuration(seconds) {
        if (seconds === null || seconds === undefined) return "";
        const s = Number(seconds);
        if (Number.isNaN(s) || s <= 0) return "";
        const mins = Math.floor(s / 60);
        const secs = s % 60;
        const padded = secs < 10 ? "0" + secs : secs;
        return mins + ":" + padded;
      }

      function renderActiveTags() {
        if (!activeTagsEl) return;
        if (!selectedTags || selectedTags.length === 0) {
          activeTagsEl.innerHTML =
            "<span style='color:#6b7280;'>No active tag filters</span>";
          return;
        }

        const pillsHtml =
          "<span style='margin-right:4px;'>Active tags (AND):</span>" +
          selectedTags
            .map((t) => {
              const label = t.replace(/</g, "&lt;");
              const attr = t.replace(/"/g, "&quot;");
              return `
              <span class="tag-chip active-tag-pill" data-tag="${attr}">
                ${label} &times;
              </span>
            `;
            })
            .join("");

        activeTagsEl.innerHTML = pillsHtml;

        activeTagsEl
          .querySelectorAll(".active-tag-pill")
          .forEach((pill) => {
            pill.addEventListener("click", () => {
              const name = pill.getAttribute("data-tag");
              removeTag(name);
            });
          });
      }

      function addTag(tagName) {
        if (!tagName) return;
        const cleaned = tagName.trim();
        if (!cleaned) return;
        const lower = cleaned.toLowerCase();
        if (selectedTags.some((t) => t.toLowerCase() === lower)) {
          return; // already selected
        }
        selectedTags.push(cleaned);
        renderActiveTags();
        refreshReleases();
      }

      function removeTag(tagName) {
        if (!tagName) return;
        const lower = tagName.toLowerCase();
        selectedTags = selectedTags.filter(
          (t) => t.toLowerCase() !== lower
        );
        renderActiveTags();
        refreshReleases();
      }

      // Attach Enter key on tag input to add a tag pill
      if (tagInput) {
        tagInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            const val = tagInput.value.trim();
            if (val) {
              addTag(val);
              tagInput.value = "";
            }
          }
        });
      }

      function wireTagClickElements(container) {
        if (!container) return;
        const chips = container.querySelectorAll(".tag-click");
        chips.forEach((chip) => {
          const tagName = chip.getAttribute("data-tag");
          if (!tagName) return;
          chip.addEventListener("click", (event) => {
            event.stopPropagation(); // don't trigger row click
            addTag(tagName);
            scrollToReleases();
          });
        });
      }

      async function loadReleaseDetails(releaseId) {
        if (!releaseId) return;
        releaseDetailsEl.innerHTML =
          '<p class="details-sub">Loading release details...</p>';

        try {
          const res = await fetch("/release/" + encodeURIComponent(releaseId));
          if (!res.ok) {
            releaseDetailsEl.innerHTML =
              '<p class="details-sub">Error loading release details.</p>';
            return;
          }

          const r = await res.json();

          const tags = (r.tags || "")
            .split(",")
            .map((t) => t.trim())
            .filter((t) => t.length > 0);

          const freeLabel =
            r.is_free === true ? "Yes" : r.is_free === false ? "No" : "";

          const dateStr = r.release_date
            ? new Date(r.release_date).toISOString().slice(0, 10)
            : "";

          const seenStr =
            typeof r.encounter_count === "number"
              ? r.encounter_count + " recorded encounter(s)"
              : "Encounters: n/a";

          let tracksHtml = "";

          if (Array.isArray(r.tracks) && r.tracks.length > 0) {
            tracksHtml += `
              <table class="track-table">
                <thead>
                  <tr>
                    <th style="width: 60%;">Track</th>
                    <th style="width: 20%;">Duration</th>
                    <th style="width: 20%;">Spotify ID</th>
                  </tr>
                </thead>
                <tbody>
            `;
            for (const t of r.tracks) {
              const titleSafe = String(t.title || "").replace(/</g, "&lt;");
              tracksHtml += `
                <tr>
                  <td>${titleSafe}</td>
                  <td>${formatDuration(t.duration)}</td>
                  <td>${t.spotify_track_id || ""}</td>
                </tr>
              `;
            }
            tracksHtml += `
                </tbody>
              </table>
            `;
          } else {
            tracksHtml =
              '<p class="details-sub">No track list recorded for this release yet.</p>';
          }

          const tagsHtml =
            tags.length > 0
              ? tags
                  .map((tRaw) => {
                    const label = tRaw.replace(/</g, "&lt;");
                    const attr = tRaw.replace(/"/g, "&quot;");
                    return `
                      <span class="tag-chip tag-click" data-tag="${attr}">
                        ${label}
                      </span>
                    `;
                  })
                  .join("")
              : "<span style='color:#6b7280;'>None recorded</span>";

          releaseDetailsEl.innerHTML = `
            <div>
              <p class="details-label">Artist</p>
              <p class="details-value">${r.artist_name || ""}</p>

              <p class="details-label">Title</p>
              <p class="details-value">${r.title || ""}</p>

              <p class="details-label">Price</p>
              <p class="details-value">${r.price_label || ""} ${
            freeLabel ? "(" + freeLabel + ")" : ""
          }</p>

              <p class="details-label">Release date</p>
              <p class="details-value">${dateStr}</p>

              <p class="details-label">Tags</p>
              <p class="details-value">
                ${tagsHtml}
              </p>

              <p class="details-label">Encounters</p>
              <p class="details-value">${seenStr}</p>

              <p class="details-label">Source</p>
              <p class="details-value">
                ${
                  r.url
                    ? '<a class="release-link" href="' +
                      r.url +
                      '" target="_blank" rel="noreferrer">Open on Bandcamp</a>'
                    : "<span style='color:#6b7280;'>No source URL recorded</span>"
                }
              </p>

              <p class="details-label">Tracks</p>
              ${tracksHtml}
            </div>
          `;

          wireTagClickElements(releaseDetailsEl);
        } catch (err) {
          console.error("Error loading release details:", err);
          releaseDetailsEl.innerHTML =
            '<p class="details-sub">Error loading release details.</p>';
        }
      }

	  let __openInlineDetailsRow = null;
	  let __openInlineForReleaseId = null;
	  
	  async function toggleInlineDetails(rowEl, releaseId, opts = {}) {
		const { fromThumb = false } = opts;
	  
		// If another release is open, close it first (only one expanded at a time)
		if (
		  __openInlineDetailsRow &&
		  __openInlineForReleaseId &&
		  __openInlineForReleaseId !== releaseId
		) {
		  try {
			__openInlineDetailsRow.remove();
		  } catch {}
		  __openInlineDetailsRow = null;
		  __openInlineForReleaseId = null;
		}
	  
		// If this release is already open, collapse it
		const existingRow = rowEl.nextElementSibling;
		if (existingRow && existingRow.classList.contains("inline-details-row")) {
		  existingRow.remove();
		  __openInlineDetailsRow = null;
		  __openInlineForReleaseId = null;
		  return false;
		}
	  
		// Create placeholder row
		const detailsRow = document.createElement("tr");
		detailsRow.className = "inline-details-row";
	  
		const detailsTd = document.createElement("td");
		detailsTd.colSpan = rowEl.children.length;
		detailsTd.innerHTML = `<div class="inline-details">Loading release details...</div>`;
	  
		detailsRow.appendChild(detailsTd);
		rowEl.insertAdjacentElement("afterend", detailsRow);
	  
		__openInlineDetailsRow = detailsRow;
		__openInlineForReleaseId = releaseId;
	  
		// Fetch release details
		try {
		  const res = await fetch("/release/" + encodeURIComponent(releaseId));
		  if (!res.ok) throw new Error(`HTTP ${res.status}`);
		  const r = await res.json();
	  
		  // Build the media slot:
		  // - If bandcamp_embed_src exists: render the iframe at full size (350Ã—470)
		  // - Otherwise: show a larger cover image placeholder
		  const bandcampEmbedSrc =
			r.bandcamp_embed_src && String(r.bandcamp_embed_src).trim()
			  ? String(r.bandcamp_embed_src).trim()
			  : "";
	  
		  const mediaArtUrl =
			r.bandcamp_art_url ||
			r.discogs_cover_image_url ||
			r.discogs_thumb_url ||
			"";
	  
		  // Bandcamp autoplay: Bandcamp iframes generally do NOT reliably support programmatic autoplay.
		  // We still pass an autoplay hint for â€œbest effortâ€; most browsers/iframes will ignore it.
		  const autoplayHint = fromThumb ? "autoplay=1" : "";
	  
		  const iframeSrc = bandcampEmbedSrc
			? (() => {
				// If the embed src already has query-ish segments, we just append a harmless suffix.
				// (Bandcamp EmbeddedPlayer URLs arenâ€™t normal querystrings, but adding this wonâ€™t break them.)
				if (!autoplayHint) return bandcampEmbedSrc;
				return bandcampEmbedSrc.includes("autoplay=")
				  ? bandcampEmbedSrc
				  : bandcampEmbedSrc.replace(/\/$/, "") + `/${autoplayHint}/`;
			  })()
			: "";
	  
		  const mediaHtml = bandcampEmbedSrc
			? `
			  <div class="bc-media-shell is-expanded">
				<iframe
				  class="bc-iframe"
				  src="${iframeSrc.replace(/"/g, "&quot;")}"
				  title="Bandcamp player"
				  seamless
				  loading="lazy"
				  allow="autoplay; encrypted-media"
				></iframe>
			  </div>
			`
			: `
			  <div class="bc-media-shell is-expanded">
				${
				  mediaArtUrl
					? `<img class="bc-fallback-art" src="${mediaArtUrl}" alt="Cover art" />`
					: `<div class="bc-no-art">No art</div>`
				}
			  </div>
			`;
	  
		  // Discogs bits (for right-side metadata area)
		  const labels = Array.isArray(r.discogs_labels)
			? r.discogs_labels.map((x) => String(x || "").trim()).filter(Boolean)
			: [];
		  const labelStr = labels.length > 0 ? labels.join(", ") : "";
		  const countryStr = r.discogs_country ? String(r.discogs_country) : "";
	  
		  const discogsAvg =
			r.discogs_rating_average == null ? null : Number(r.discogs_rating_average);
		  const discogsCount =
			r.discogs_rating_count == null ? null : Number(r.discogs_rating_count);
	  
		  const discogsRatingLine =
			discogsAvg == null
			  ? "<span style='color:#6b7280;'>No Discogs rating yet</span>"
			  : `<span>${discogsAvg.toFixed(2)} / 5</span>`;
	  
		  const discogsCountLine =
			discogsCount == null
			  ? ""
			  : `<div style="font-size:11px; color:#9ca3af; margin-top:2px;">${discogsCount} rating${
				  discogsCount === 1 ? "" : "s"
				}</div>`;
	  
		  const discogsMetaLine =
			labelStr || countryStr
			  ? `<div style="font-size:12px; color:#d1d5db; margin-top:6px;">
				   ${
					 countryStr
					   ? `<div><span style="color:#9ca3af;">Country:</span> ${countryStr}</div>`
					   : ""
				   }
				   ${
					 labelStr
					   ? `<div><span style="color:#9ca3af;">Label:</span> ${labelStr}</div>`
					   : ""
				   }
				 </div>`
			  : `<div style="font-size:12px; color:#6b7280; margin-top:6px;">No Discogs label/country recorded</div>`;
	  
		  const discogsSummaryHtml = `
			<div style="margin-top:4px;">
			  <div style="font-size:12px; color:#9ca3af;">Discogs</div>
			  <div style="font-size:13px; color:#e5e7eb; margin-top:2px;">
				${discogsRatingLine}
				${discogsCountLine}
			  </div>
			  ${discogsMetaLine}
			</div>
		  `;
	  
				// Tracks (right column, compact list)
		  const tracks = Array.isArray(r.tracks) ? r.tracks : [];
		  const tracksHtml =
			tracks.length > 0
			  ? `
				<div class="details-tracks-right">
				  <div class="details-label">Tracks</div>
				  <div class="tracklist">
					${tracks
					  .map((t) => {
						const title = String(t.title || "").replace(/</g, "&lt;");
						const dur = Number(t.duration || 0);
						const mm = dur ? Math.floor(dur / 60) : 0;
						const ss = dur ? String(dur % 60).padStart(2, "0") : "00";
						const durStr = dur ? `${mm}:${ss}` : "";
						return `
						  <div class="track-row">
							<div class="track-title">${title}</div>
							<div class="track-dur">${durStr}</div>
						  </div>
						`;
					  })
					  .join("")}
				  </div>
				</div>
			  `
			  : `<div class="details-tracks-right"><div class="details-label">Tracks</div><div style="color:#6b7280; font-size:12px; margin-top:6px;">No tracks recorded</div></div>`;

		  // Tags + Stickers (votable attachments)
		  const attachments = Array.isArray(r.tag_attachments) ? r.tag_attachments : [];

		  function srcIconHtml(src) {
			if (src === "bandcamp") {
			  return `<img class="src-icon" src="/assets/bandcamp.png" alt="Bandcamp" />`;
			}
			if (src === "discogs_genre" || src === "discogs_style") {
			  return `<img class="src-icon" src="/assets/discogs-white.png" alt="Discogs" />`;
			}
			// user stickers: no source icon (less busy)
			return "";
		  }

		  const attachmentsHtml =
			attachments.length > 0
			  ? `<div class="attach-row">
				   ${attachments
					 .map((a) => {		 
					   const name = String(a.tag_name || "").replace(/</g, "&lt;");
					   const iconHtml = srcIconHtml(a.source);			   
					   const up = Number(a.upvotes || 0);
					   const down = Number(a.downvotes || 0);
					   const canUp = a.can_upvote === true;
					   const canDown = a.can_downvote === true;
					   const canRemove = a.can_remove === true;
					   const isMineSticker = a.source === "user" && __bitrotMe && a.created_by_account_id === __bitrotMe.id;
					   const totalVotes = Number(a.upvotes || 0) + Number(a.downvotes || 0);  
					   return `
						<span class="attach-chip"
						  data-release-id="${String(r.id || releaseId)}"
						  data-release-tag-id="${String(a.release_tag_id)}"
						  data-my-vote-value="${String(Number(a.my_vote_value || 0))}">
						   ${iconHtml}<span>${name}</span>
						   <button class="vote-btn vote-up" ${canUp ? "" : "disabled"} title="Upvote">â–²</button>
						   <span class="vote-count upcount">${up}</span>
						   <button class="vote-btn vote-down" ${canDown ? "" : "disabled"} title="Downvote (stickers only)">â–¼</button>
						   <span class="vote-count downcount">${down}</span>
						  ${
							isMineSticker
							  ? `<button class="remove-btn sticker-remove" ${canRemove ? "" : "disabled"}
								   title="${canRemove ? "Remove your sticker" : `Can't remove after votes (${totalVotes} total)`}">
								   remove
								 </button>`
							  : ""
						  }	
						 </span>	 
					   `;
					 })
					 .join("")}
				 </div>`
			  : `<div style="color:#6b7280; font-size:12px; margin-top:6px;">No tags attached yet</div>`;

		  const stickerAddHtml =
			__bitrotMe
			  ? `
				<div class="stickers-add-row">
				  <div class="typeahead">
					<input class="sticker-input" type="text" placeholder="Add sticker (choose existing tag)..." />
					<div class="typeahead-list"></div>
				  </div>
				  <button class="btn btn-secondary sticker-add-btn" disabled>Add</button>
				  <span style="color:#9ca3af; font-size:11px;" class="sticker-add-msg"></span>
				</div>
			  `
			  : `<div style="color:#9ca3af; font-size:11px; margin-top:6px;">Log in to add stickers or vote.</div>`;

		  const tagsBlockHtml = `
			<div class="stickers-panel" data-release-id="${String(r.id || releaseId)}">
			  <div class="details-label">Tags + Stickers</div>
			  ${attachmentsHtml}
			  ${stickerAddHtml}
			</div>
		  `;
  
		  // Render: media left, metadata middle, tracks right (all locked to player height)
		  detailsTd.innerHTML = `
			<div class="inline-details">
			  <div class="details-top">
				<div class="details-media">
				  ${mediaHtml}
				  ${
					r.url
					  ? `<div style="margin-top:10px; font-size:12px;">
						   <a class="release-link" href="${r.url}" target="_blank" rel="noreferrer">Open on Bandcamp</a>
						 </div>`
					  : ""
				  }
				</div>
		  
				<div class="details-meta">
				  <div class="details-grid">
					<div>
					  <div class="details-label">Release ID</div>
					  <div class="details-value" style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
						<code style="font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 12px; color:#e5e7eb;">
						  ${r.id || releaseId}
						</code>
						<button class="copy-id-btn" data-id="${r.id || releaseId}">Copy ID</button>
					  </div>
					</div>
		  
					<div>
					  <div class="details-label">Artist</div>
					  <div class="details-value">${String(r.artist_name || "")}</div>
					</div>
		  
					<div>
					  <div class="details-label">Title</div>
					  <div class="details-value">${String(r.title || "")}</div>
					</div>
		  
					<div>
					  <div class="details-label">Release date</div>
					  <div class="details-value">${r.release_date ? String(r.release_date).slice(0, 10) : ""}</div>
					</div>
		  
					<div>
					  <div class="details-label">Price</div>
					  <div class="details-value">${String(r.price_label || "")}</div>
					</div>
		  
					<div>
					  <div class="details-label">Encounters</div>
					  <div class="details-value">${Number(r.encounter_count || 0)}</div>
					</div>
				  </div>
		  
				  ${discogsSummaryHtml}
				  ${tagsBlockHtml}
				</div>
		  
				<div class="details-right">
				  ${tracksHtml}
				</div>
			  </div>
			</div>
		  `;

		// Apply album-art-driven theming to the expanded pane
		try {
		  const pane = detailsTd.querySelector(".inline-details");
		  await applyArtworkThemeToExpandedPane(pane, mediaArtUrl);
		} catch (_e) {}
		
		  // Wire Copy ID + tag clicks inside the expanded content
		  wireTagClickElements(detailsTd);

          // ---------- Stickers/Votes wiring ----------
          (function wireStickersAndVotes(container, releaseObj) {
            const panel = container.querySelector(".stickers-panel");
            if (!panel) return;

            const releaseIdStr = panel.getAttribute("data-release-id") || "";

            // Typeahead (only if logged in)
            const input = panel.querySelector("input.sticker-input");
            const list = panel.querySelector(".typeahead-list");
            const addBtn = panel.querySelector("button.sticker-add-btn");
            const msgEl = panel.querySelector(".sticker-add-msg");

            let selectedTagId = null;

            function setMsg(msg) {
              if (!msgEl) return;
              msgEl.textContent = msg || "";
            }

            async function refreshPanel() {
              const res = await fetch("/release/" + encodeURIComponent(releaseIdStr), {
                credentials: "same-origin",
              });
              if (!res.ok) return;
              const fresh = await res.json();

              const attachments = Array.isArray(fresh.tag_attachments)
                ? fresh.tag_attachments
                : [];

			  function srcIconHtml(src) {
			  if (src === "bandcamp") {
			  return `<img class="src-icon" src="/assets/bandcamp.png" alt="Bandcamp" />`;
			  }
			  if (src === "discogs_genre" || src === "discogs_style") {
			  return `<img class="src-icon" src="/assets/discogs-white.png" alt="Discogs" />`;
			  }
			  // user stickers: no source icon (less busy)
			  return "";
			  }

              const attachmentsHtml =
                attachments.length > 0
                  ? `<div class="attach-row">
                       ${attachments
                         .map((a) => {
                           const name = String(a.tag_name || "").replace(/</g, "&lt;");
                           const iconHtml = srcIconHtml(a.source);
                            const up = Number(a.upvotes || 0);
                            const down = Number(a.downvotes || 0);
                            const canUp = a.can_upvote === true;
                            const canDown = a.can_downvote === true;
                            const canRemove = a.can_remove === true;

                            const myVote = Number(a.my_vote_value || 0);
                            const upActive = myVote === 1 ? "active" : "";
                            const downActive = myVote === -1 ? "active" : "";

                            return `
							<span class="attach-chip"
							  data-release-id="${String(fresh.id || releaseIdStr)}"
							  data-release-tag-id="${String(a.release_tag_id)}"
							  data-my-vote-value="${String(myVote)}">
                                ${iconHtml}<span>${name}</span>
                                <button class="vote-btn vote-up ${upActive}" ${canUp ? "" : "disabled"} title="Upvote" aria-pressed="${myVote === 1 ? "true" : "false"}">â–²</button>
                                <span class="vote-count upcount">${up}</span>
                                <button class="vote-btn vote-down ${downActive}" ${canDown ? "" : "disabled"} title="Downvote (stickers only)" aria-pressed="${myVote === -1 ? "true" : "false"}">â–¼</button>
                                <span class="vote-count downcount">${down}</span>
                                ${
                                  canRemove
                                    ? `<button class="remove-btn sticker-remove" title="Remove your sticker (only if no votes)">remove</button>`
                                    : ""
                                }
                              </span>
                            `;  
                         })
                         .join("")}
                     </div>`
                  : `<div style="color:#6b7280; font-size:12px; margin-top:6px;">No tags attached yet</div>`;

              const stickerAddHtml =
                __bitrotMe
                  ? `
                    <div class="stickers-add-row">
                      <div class="typeahead">
                        <input class="sticker-input" type="text" placeholder="Add sticker (choose existing tag)..." />
                        <div class="typeahead-list"></div>
                      </div>
                      <button class="btn btn-secondary sticker-add-btn" disabled>Add</button>
                      <span style="color:#9ca3af; font-size:11px;" class="sticker-add-msg"></span>
                    </div>
                  `
                  : `<div style="color:#9ca3af; font-size:11px; margin-top:6px;">Log in to add stickers or vote.</div>`;

              // Replace only the stickers panel content (no collapsing/reopening the expanded view)
              panel.innerHTML = `
                <div class="details-label">Tags + Stickers</div>
                ${attachmentsHtml}
                ${stickerAddHtml}
              `;

              // Re-wire events on the new panel DOM
              wireStickersAndVotes(container, fresh);
            }

            async function vote(releaseTagId, value) {
              const res = await fetch(
                "/release/" + encodeURIComponent(releaseIdStr) + "/tags/" + encodeURIComponent(releaseTagId) + "/vote",
                {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  credentials: "same-origin",
                  body: JSON.stringify({ value }),
                }
              );
              if (!res.ok) {
                let data = null;
                try { data = await res.json(); } catch {}
                alert((data && data.error) || "Vote failed.");
                return;
              }
              await refreshPanel();
            }

            async function undoVote(releaseTagId) {
              const res = await fetch(
                "/release/" + encodeURIComponent(releaseIdStr) + "/tags/" + encodeURIComponent(releaseTagId) + "/vote",
                { method: "DELETE", credentials: "same-origin" }
              );
              if (!res.ok) {
                let data = null;
                try { data = await res.json(); } catch {}
                alert((data && data.error) || "Undo failed.");
                return;
              }
              await refreshPanel();
            }

            async function removeSticker(releaseTagId) {
              const res = await fetch(
                "/release/" + encodeURIComponent(releaseIdStr) + "/stickers/" + encodeURIComponent(releaseTagId),
                { method: "DELETE", credentials: "same-origin" }
              );
              if (!res.ok) {
                let data = null;
                try { data = await res.json(); } catch {}
                alert((data && data.error) || "Remove failed.");
                return;
              }
              await refreshPanel();
            }

			// Delegated click handler for vote/remove buttons
			panel.addEventListener("click", async (ev) => {
			  const chip = ev.target.closest(".attach-chip");
			  if (!chip) return;
			
			  const rtId = chip.getAttribute("data-release-tag-id");
			  if (!rtId) return;
			
			  // -1 = user downvoted, 0 = no vote, 1 = user upvoted
			  const myVote = Number(chip.getAttribute("data-my-vote-value") || 0);
			
			  const upBtn = ev.target.closest("button.vote-up");
			  const downBtn = ev.target.closest("button.vote-down");
			  const rmBtn = ev.target.closest("button.sticker-remove");
			
			  if (upBtn) {
				ev.stopPropagation();
				if (upBtn.disabled) return;
			
				// Toggle off if already upvoted, otherwise set upvote (switches from downvote too)
				if (myVote === 1) {
				  await undoVote(rtId);
				} else {
				  await vote(rtId, 1);
				}
				return;
			  }
			
			  if (downBtn) {
				ev.stopPropagation();
				if (downBtn.disabled) return;
			
				// Toggle off if already downvoted, otherwise set downvote (switches from upvote too)
				if (myVote === -1) {
				  await undoVote(rtId);
				} else {
				  await vote(rtId, -1);
				}
				return;
			  }		
			  		  
			  if (rmBtn) {
				ev.stopPropagation();
				if (rmBtn.disabled) return;
				await removeSticker(rtId);
				return;
			  }
			  
			});

            if (!input || !list || !addBtn) return;

            function showList(items) {
              list.innerHTML = "";
              if (!items || items.length === 0) {
                list.style.display = "none";
                return;
              }

              list.style.display = "block";
              for (const it of items) {
                const div = document.createElement("div");
                div.className = "typeahead-item";
                div.textContent = it.name;
                div.setAttribute("data-tag-id", String(it.id));
                div.setAttribute("data-tag-name", String(it.name));
                list.appendChild(div);
              }
            }

            input.addEventListener("input", async () => {
              selectedTagId = null;
              addBtn.disabled = true;
              setMsg("");

              const q = String(input.value || "").trim();
              if (q.length < 2) {
                showList([]);
                return;
              }

              try {
                const res = await fetch("/tag_pool?q=" + encodeURIComponent(q));
                if (!res.ok) return showList([]);
                const data = await res.json();
                const items = Array.isArray(data.tags) ? data.tags : [];
                showList(items.slice(0, 50));
              } catch {
                showList([]);
              }
            });

            list.addEventListener("click", (ev) => {
              const item = ev.target.closest(".typeahead-item");
              if (!item) return;
              const id = item.getAttribute("data-tag-id");
              const name = item.getAttribute("data-tag-name");
              if (!id || !name) return;

              selectedTagId = Number(id);
              input.value = name;
              showList([]);
              addBtn.disabled = false;
            });

            document.addEventListener("click", (ev) => {
              if (!panel.contains(ev.target)) showList([]);
            });

            addBtn.addEventListener("click", async () => {
              if (!selectedTagId) return;
              addBtn.disabled = true;
              setMsg("Addingâ€¦");

              const res = await fetch(
                "/release/" + encodeURIComponent(releaseIdStr) + "/stickers",
                {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  credentials: "same-origin",
                  body: JSON.stringify({ tag_id: selectedTagId }),
                }
              );

              let data = null;
              try { data = await res.json(); } catch {}

              if (!res.ok) {
                setMsg((data && data.error) || "Failed.");
                addBtn.disabled = false;
                return;
              }

              // reset
              input.value = "";
              selectedTagId = null;
              setMsg("Added.");
              await refreshPanel();
            });
          })(detailsTd, r);
	  
		  const copyBtn = detailsTd.querySelector(".copy-id-btn");
		  if (copyBtn) {
			copyBtn.addEventListener("click", async (e) => {
			  e.stopPropagation();
			  const id = copyBtn.getAttribute("data-id") || "";
			  try {
				await navigator.clipboard.writeText(id);
				copyBtn.textContent = "Copied!";
				setTimeout(() => (copyBtn.textContent = "Copy ID"), 800);
			  } catch {
				// ignore
			  }
			});
		  }
	  
		  return true;
		  
		} catch (err) {
		  console.error(err);
		  const msg =
			err && err.message ? String(err.message) : String(err || "unknown error");
		  detailsTd.innerHTML = `<div class="inline-details">Error loading release details: <span style="color:#9ca3af;">${msg.replace(
			/</g,
			"&lt;"
		  )}</span></div>`;
		  return true; // still expanded, but errored
		}
		
	  }

  	// Create a placeholder row right under the clicked row

      // ---------- Releases listing logic ----------

      const releasesBody = document.getElementById("releases-body");
      const statusEl = document.getElementById("status");

      const artistInput = document.getElementById("filter-artist");
      const idInput = document.getElementById("filter-id");
      const globalInput = document.getElementById("filter-global");
      const freeSelect = document.getElementById("filter-free");
      const applyBtn = document.getElementById("filter-apply");

      let currentPage = 0;
      let currentSortBy = null;
      let currentSortDir = "desc";

      let isLoadingReleases = false;
      let hasMoreReleases = true;
      const PAGE_SIZE = 20; // must match backend limit

      function clearReleasesTable() {
        releasesBody.innerHTML = "";
      }

      function resetReleases() {
        currentPage = 0;
        hasMoreReleases = true;
        isLoadingReleases = false;
        clearReleasesTable();
        statusEl.textContent = "";
      }

      async function loadNextReleasesPage() {
        if (isLoadingReleases || !hasMoreReleases) return;

        isLoadingReleases = true;
        const pageToLoad = currentPage + 1;

        const params = new URLSearchParams();
        if (artistInput && artistInput.value.trim() !== "") {
          params.set("artist", artistInput.value.trim());
        }
        if (freeSelect && freeSelect.value !== "") {
          params.set("free", freeSelect.value);
        }
        if (selectedTags.length > 0) {
          params.set("tag", selectedTags.join(","));
        }
        if (currentSortBy) {
          params.set("sort_by", currentSortBy);
          params.set("sort_dir", currentSortDir);
        }
        params.set("page", String(pageToLoad));
        
		// Global search must be applied BEFORE fetching
		if (globalInput && globalInput.value.trim() !== "") {
		  params.set("q", globalInput.value.trim());
		}

        statusEl.textContent =
          pageToLoad === 1 ? "Loading releases..." : "Loading more releases...";

        try {
          const res = await fetch("/releases?" + params.toString());
          if (!res.ok) {
            throw new Error("Failed to load releases");
          }

          let rows = await res.json();
          if (!Array.isArray(rows)) rows = [];

          // ID filter (substring of UUID)
          if (idInput && idInput.value.trim() !== "") {
            const idTerm = idInput.value.trim().toLowerCase();
            rows = rows.filter(
              (row) => row.id && String(row.id).toLowerCase().includes(idTerm)
            );
          }

          if (!Array.isArray(rows) || rows.length === 0) {
            if (pageToLoad === 1) {
              releasesBody.innerHTML =
                '<tr><td colspan="10">No releases found for this filter set.</td></tr>';

            }
            hasMoreReleases = false;
          } else {
            for (const row of rows) {
              const tr = document.createElement("tr");

			  const bandcampTags = (row.tags || "")
				.split(",")
				.map((t) => t.trim())
				.filter((t) => t.length > 0);
			  
			  const discogsGenres = Array.isArray(row.discogs_genres)
				? row.discogs_genres.map((x) => String(x || "").trim()).filter(Boolean)
				: [];
			  
			  const discogsStyles = Array.isArray(row.discogs_styles)
				? row.discogs_styles.map((x) => String(x || "").trim()).filter(Boolean)
				: [];
			  
			  const freeLabel =
				row.is_free === true
				  ? "Yes"
				  : row.is_free === false
				  ? "No"
				  : "";
			  
			  const dateStr = row.release_date
				? new Date(row.release_date).toISOString().slice(0, 10)
				: "";
			  
			  function renderChips(list) {
				return list
				  .map((tRaw) => {
					const label = tRaw.replace(/</g, "&lt;");
					const attr = tRaw.replace(/"/g, "&quot;");
					return `
					  <span class="tag-chip tag-click" data-tag="${attr}">
						${label}
					  </span>
					`;
				  })
				  .join("");
			  }
			  
			  // Bandcamp first, then Discogs genres, then Discogs styles
			  const parts = [];
			  if (bandcampTags.length) parts.push(renderChips(bandcampTags));
			  if (discogsGenres.length) parts.push(renderChips(discogsGenres));
			  if (discogsStyles.length) parts.push(renderChips(discogsStyles));
			  
			  // Use a subtle separator between tag groups
			  const tagsHtml = parts.join(
				`<span style="color:#374151; margin:0 6px;">|</span>`
			  );

              const encounters = Number(row.unique_visits ?? 0);

			  const artUrl =
				row.bandcamp_art_url || row.discogs_thumb_url || row.discogs_cover_image_url || "";
			  
			  const artHtml = artUrl
				? `<img
					 class="release-thumb"
					 src="${artUrl}"
					 alt="art"
					 loading="lazy"
					 style="width:100px;height:100px;object-fit:cover;border-radius:6px;border:1px solid #1f2933; cursor:pointer;"
				   />`
				: `<div class="release-thumb"
					 style="width:100px;height:100px;border-radius:6px;border:1px solid #1f2933;
					 display:flex;align-items:center;justify-content:center;color:#6b7280;font-size:11px; cursor:pointer;">â€”</div>`;

			  tr.innerHTML = `
				<td style="display:none;">
				  ${row.id || ""}
				</td>
			  
				<td class="art-cell">
				  ${artHtml}
				</td>
			  
				<td>${row.artist_name || ""}</td>
				<td>${row.title || ""}</td>
				<td>${row.price_label || ""}</td>
				<td>${dateStr}</td>
				<td>${tagsHtml}</td>
				<td>${encounters}</td>
			  
				<td>${
				  row.url
					? '<a class="release-link" href="' +
					  row.url +
					  '" target="_blank" rel="noreferrer">Bandcamp</a>'
					: ""
				}</td>
			  
				<td data-discogs-cell="1" data-release-id="${row.id || ""}">
				  <span class="discogs-none">-</span>
				</td>
			  `;

			  tr.addEventListener("click", async (ev) => {
				// Donâ€™t toggle expand when clicking links, tag chips, or buttons
				if (
				  ev.target.closest("a") ||
				  ev.target.closest(".tag-click") ||
				  ev.target.closest(".copy-id-btn")
				) {
				  return;
				}
			  
				const fromThumb = !!ev.target.closest(".release-thumb");
			  
				// Expand/collapse inline
				const didExpand = await toggleInlineDetails(tr, row.id, { fromThumb });
			  
				// Only run Discogs matching on EXPAND (never on collapse)
				if (didExpand) {
				  triggerDiscogsMatchForReleaseId(row.id);
				}
			  });

              releasesBody.appendChild(tr);
              wireTagClickElements(tr);
            }

            // Fill Discogs confidence cells for the rows we just rendered
            hydrateDiscogsCellsForVisibleRows(rows);

            currentPage = pageToLoad;

            if (rows.length < PAGE_SIZE) {
              hasMoreReleases = false;
            }
          }

          const total = Number(res.headers.get("X-Total-Count")) || 0;
		  statusEl.textContent = `Found ${total} matching release(s).`;
        } catch (err) {
          console.error(err);
          statusEl.textContent = "Error loading releases.";
          if (currentPage === 0) {
            releasesBody.innerHTML =
              '<tr><td colspan="10">Error loading releases.</td></tr>';

          }
        } finally {
          isLoadingReleases = false;
        }
      }

      function refreshReleases() {
        resetReleases();
        loadNextReleasesPage();
      }

      if (applyBtn) {
        applyBtn.addEventListener("click", () => {
          refreshReleases();
        });
      }

      // Sortable column headers
      document
        .querySelectorAll("th.sortable[data-sort]")
        .forEach((th) => {
          th.addEventListener("click", () => {
            const key = th.getAttribute("data-sort");
            if (!key) return;

            if (currentSortBy === key) {
              currentSortDir = currentSortDir === "asc" ? "desc" : "asc";
            } else {
              currentSortBy = key;
              currentSortDir = "asc";
            }

            refreshReleases();
          });
        });

      // Infinite scroll: when near bottom of the page, load next page
      
      const releasesScroll = document.querySelector(".releases-scroll");

	  releasesScroll.addEventListener("scroll", () => {
  		const nearBottom =
    	  releasesScroll.scrollTop + releasesScroll.clientHeight >=
   		  releasesScroll.scrollHeight - 200;

  		if (nearBottom) {
    	  loadNextReleasesPage();
  		}
	  });



      // ---------- Spotify overlap logic ----------

      const overlapBtn = document.getElementById("spotify-check-overlap");
      const overlapOutput = document.getElementById("spotify-overlap-output");
      const spotifyOverlapBody = document.getElementById("spotify-overlap-body");
      const overlapFreeOnlyCheckbox = document.getElementById(
        "spotify-overlap-free-only"
      );

      // We'll keep the last overlap result in memory so we can re-filter
      let lastOverlapData = null;

      function renderSpotifyOverlapTable(rows) {
        spotifyOverlapBody.innerHTML = "";

        if (!rows || rows.length === 0) {
          spotifyOverlapBody.innerHTML =
            '<tr><td colspan="7" style="font-size: 12px; color: #9ca3af;">No overlapping releases found.</td></tr>';
          return;
        }

        for (const row of rows) {
          const tr = document.createElement("tr");

          const tags = (row.tags || "")
            .split(",")
            .map((t) => t.trim())
            .filter((t) => t.length > 0);

          const freeLabel =
            row.is_free === true
              ? "Yes"
              : row.is_free === false
              ? "No"
              : "";

          const dateStr = row.release_date
            ? new Date(row.release_date).toISOString().slice(0, 10)
            : "";

          const tagsHtml =
            tags.length > 0
              ? tags
                  .map((tRaw) => {
                    const label = tRaw.replace(/</g, "&lt;");
                    const attr = tRaw.replace(/"/g, "&quot;");
                    return `
                      <span class="tag-chip tag-click" data-tag="${attr}">
                        ${label}
                      </span>
                    `;
                  })
                  .join("")
              : "";

          tr.innerHTML = `
            <td>${row.artist_name || ""}</td>
            <td>${row.title || ""}</td>
            <td>${row.price_label || ""}</td>
            <td>${freeLabel}</td>
            <td>${dateStr}</td>
            <td>${tagsHtml}</td>
            <td>${
              row.url
                ? '<a class="release-link" href="' +
                  row.url +
                  '" target="_blank" rel="noreferrer">Bandcamp</a>'
                : ""
            }</td>
          `;

          // Make overlap rows clickable too
          tr.style.cursor = "pointer";
          tr.addEventListener("click", () => {
            loadReleaseDetails(row.id);
          });

          spotifyOverlapBody.appendChild(tr);
          wireTagClickElements(tr);
        }
      }

      function filterOverlapRows(data) {
        if (!data || !Array.isArray(data.matched_releases)) return [];
        const rows = data.matched_releases;

        if (!overlapFreeOnlyCheckbox.checked) {
          return rows;
        }

        // Free / NYP filter: is_free === true
        return rows.filter((row) => row.is_free === true);
      }

      overlapFreeOnlyCheckbox.addEventListener("change", () => {
        if (!lastOverlapData) return;
        const filtered = filterOverlapRows(lastOverlapData);
        renderSpotifyOverlapTable(filtered);
      });

      overlapBtn.addEventListener("click", async () => {
        overlapOutput.textContent = "Checking overlap with Spotify...";
        overlapBtn.disabled = true;
        try {
          const res = await fetch("/spotify/overlap");
          const data = await res.json();

          if (!res.ok) {
            overlapOutput.textContent =
              data && data.error
                ? "Error: " + data.error
                : "Error checking overlap.";
            lastOverlapData = null;
            renderSpotifyOverlapTable([]);
          } else {
            lastOverlapData = data;

            overlapOutput.textContent =
              `Spotify user: ${data.spotify_user_id}\n` +
              `Saved tracks fetched (capped): ${data.total_spotify_tracks}\n` +
              `Unique albums (artist + title): ${data.total_spotify_albums}\n` +
              `Bitrot releases matched: ${data.bitrot_matched_releases}`;

            const filtered = filterOverlapRows(data);
            renderSpotifyOverlapTable(filtered);
          }
        } catch (err) {
          console.error(err);
          overlapOutput.textContent = "Error checking overlap.";
          lastOverlapData = null;
          renderSpotifyOverlapTable([]);
        } finally {
          overlapBtn.disabled = false;
        }
      });

      // ---------- Artists + Tags table logic ----------

      const artistsBody = document.getElementById("artists-body");
      const tagsBody = document.getElementById("tags-body");

      async function loadArtists() {
        try {
          const res = await fetch("/artists");
          if (!res.ok) {
            throw new Error("Failed to load artists");
          }
          const rows = await res.json();

          artistsBody.innerHTML = "";

          if (!Array.isArray(rows) || rows.length === 0) {
            artistsBody.innerHTML =
              '<tr><td colspan="3" style="font-size: 12px; color: #9ca3af;">No artists found yet.</td></tr>';
            return;
          }

          for (const row of rows) {
            const tr = document.createElement("tr");
            tr.innerHTML = `
              <td>${row.artist_name || ""}</td>
              <td>${row.release_count}</td>
              <td>${row.free_release_count}</td>
            `;
            tr.style.cursor = "pointer";
            tr.addEventListener("click", () => {
              // Clicking an artist fills the artist filter and reloads releases
              artistInput.value = row.artist_name || "";
              refreshReleases();
              scrollToReleases();
            });
            artistsBody.appendChild(tr);
          }
        } catch (err) {
          console.error("Error loading artists:", err);
          artistsBody.innerHTML =
            '<tr><td colspan="3" style="font-size: 12px; color: #9ca3af;">Error loading artists.</td></tr>';
        }
      }

      async function loadTags() {
        try {
          const res = await fetch("/tags");
          if (!res.ok) {
            throw new Error("Failed to load tags");
          }
          const rows = await res.json();

          tagsBody.innerHTML = "";

          if (!Array.isArray(rows) || rows.length === 0) {
            tagsBody.innerHTML =
              '<tr><td colspan="3" style="font-size: 12px; color: #9ca3af;">No tags found yet.</td></tr>';
            return;
          }

          for (const row of rows) {
            const tr = document.createElement("tr");
            tr.innerHTML = `
              <td>${row.name || ""}</td>
              <td>${row.release_count}</td>
              <td>${row.free_release_count}</td>
            `;
            tr.style.cursor = "pointer";
            tr.addEventListener("click", () => {
              // Clicking a tag adds it as an active tag pill (AND filter)
              addTag(row.name || "");
              scrollToReleases();
            });
            tagsBody.appendChild(tr);
          }
        } catch (err) {
          console.error("Error loading tags:", err);
          tagsBody.innerHTML =
            '<tr><td colspan="3" style="font-size: 12px; color: #9ca3af;">Error loading tags.</td></tr>';
        }
      }

		async function loadStats() {
		  try {
			const res = await fetch("/stats/summary");
			if (!res.ok) throw new Error("Failed to load /stats/summary");
			const stats = await res.json();
		
			const elReleases = document.getElementById("stats-total-releases");
			const elArtists = document.getElementById("stats-total-artists");
			const elTracks = document.getElementById("stats-total-tracks");
			const elFreeReleases = document.getElementById("stats-total-free-releases");
			const elFreeTracks = document.getElementById("stats-total-free-tracks");
		
			if (elReleases) elReleases.textContent = `${stats.total_releases ?? 0} releases`;
			if (elArtists) elArtists.textContent = `${stats.unique_artists ?? 0} artists`;
			if (elTracks) elTracks.textContent = `${stats.total_tracks ?? 0} tracks`;
			if (elFreeReleases) elFreeReleases.textContent = `${stats.total_free_releases ?? 0} free/NYP releases`;
			if (elFreeTracks) elFreeTracks.textContent = `${stats.total_free_tracks ?? 0} free/NYP tracks`;
		  } catch (err) {
			console.warn("[Bitrot] Failed to load stats:", err);
		  }
		}

      // Initial loads
      renderActiveTags();
      loadStats();
      refreshReleases();
      loadArtists();
      loadTags();
      refreshAuthState();
    
	// Global click handler for "Copy ID" buttons
	document.addEventListener("click", async (event) => {
	
	  // Discogs refresh button (dev-only)
	  const refreshBtn = event.target.closest(".discogs-refresh-btn");
	  if (refreshBtn) {
		event.stopPropagation();
		const releaseId = refreshBtn.dataset.releaseId;
		if (!releaseId) return;
	
		// Force bypass both frontend + backend cooldowns
		await triggerDiscogsMatchForReleaseId(releaseId, { force: true });
		return;
	  }
	
	  // Copy ID button
	  const button = event.target.closest(".copy-id-btn");
	  if (!button) return;
	
	  // Avoid triggering the row click that loads details
	  event.stopPropagation();
	
	  const id = button.dataset.id;
	  if (!id) return;
	
	  try {
		await navigator.clipboard.writeText(id);
		const originalText = button.textContent;
		button.textContent = "Copied!";
		setTimeout(() => {
		  button.textContent = originalText || "Copy ID";
		}, 1000);
	  } catch (err) {
		console.warn("[Bitrot] Failed to copy ID:", err);
		const originalText = button.textContent;
		button.textContent = "Copy failed";
		setTimeout(() => {
		  button.textContent = originalText || "Copy ID";
		}, 1200);
	  }
	});
	
	
	// Global click handler for artist filter buttons
	document.addEventListener("click", (event) => {
	  const button = event.target.closest(".artist-filter-btn");
	  if (!button) return;
	
	  event.stopPropagation();
	
	  const artistName = button.dataset.artist || "";
	  const artistInput = document.getElementById("filter-artist");
	  if (artistInput) {
		artistInput.value = artistName;
	  }
	
	  if (typeof currentFilters === "object") {
		currentFilters.artist = artistName;
		currentFilters.page = 1;
	  }
	
	  if (typeof loadReleases === "function") {
		loadReleases();
	  }
	});


    </script>
  </body>
</html>
